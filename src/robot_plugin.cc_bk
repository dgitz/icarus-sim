#ifndef _ROBOT_PLUGIN_HH_
#define _ROBOT_PLUGIN_HH_

#include <gazebo/gazebo.hh>
#include <gazebo/physics/physics.hh>
#include <gazebo/transport/transport.hh>
#include <gazebo/msgs/msgs.hh>
#include <thread>
#include "ros/ros.h"
#include "ros/callback_queue.h"
#include "ros/subscribe_options.h"
#include "std_msgs/Float32.h"
#include "RobotModel.h"

namespace gazebo
{
/// \brief A plugin to control a Velodyne sensor.
class RobotPlugin : public ModelPlugin
{
	/// \brief Constructor
public: RobotPlugin() {}

/// \brief The load function is called by Gazebo when the plugin is
/// inserted into simulation
/// \param[in] _model A pointer to the model that this plugin is
/// attached to.
/// \param[in] _sdf A pointer to the plugin's SDF element.
public: virtual void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf)
{
	printf("Plugin init\n");
	// Safety check
	if (_model->GetJointCount() == 0)
	{
		std::cerr << "Invalid joint count, robot plugin not loaded\n";
		return;
	}
	printf("Joint Count: %d\n",_model->GetJointCount());
	// Store the model pointer for convenience.
	this->model = _model;
	robot = std::unique_ptr<RobotModel>(new RobotModel());
	if(robot->init(this->model) == false)
	{

		printf("Robot Failed to Load.\n");
		return;
	}
	robot->print_model();
	joints = this->robot->get_joints_drivetrain_left();
	// Get the first joint. We are making an assumption about the model
	// having one joint that is the rotational joint.
	this->joint = _model->GetJoints()[0];


	// Setup a P-controller, with a gain of 0.1.
	this->pid = common::PID(0.1, 0, 0);

	// Apply the P-controller to the joint.

	for(int i = 0; i < _model->GetJointCount(); ++i)
	{
		//printf("[%d] Name: %s\n",i, _model->GetJoints()[i]->GetScopedName().c_str());
		this->model->GetJointController()->SetVelocityPID(
				this->model->GetJoints()[i]->GetScopedName(), this->pid);
	}




	// Create the node
	this->node = transport::NodePtr(new transport::Node());
#if GAZEBO_MAJOR_VERSION < 8
	this->node->Init(this->model->GetWorld()->GetName());
#else
	this->node->Init(this->model->GetWorld()->Name());
#endif

	// Initialize ros, if it has not already bee initialized.
	if (!ros::isInitialized())
	{
		int argc = 0;
		char **argv = NULL;
		ros::init(argc, argv, "gazebo_client",
				ros::init_options::NoSigintHandler);
	}

	// Create our ROS node. This acts in a similar manner to
	// the Gazebo node
	this->rosNode.reset(new ros::NodeHandle("gazebo_client"));

	// Create a named topic, and subscribe to it.
	{
		ros::SubscribeOptions so =
				ros::SubscribeOptions::create<std_msgs::Float32>(
						"/" + this->model->GetName() + "/drivetrain_left_cmd",
						1,
						boost::bind(&RobotPlugin::drivetrain_left_cmd, this, _1),
						ros::VoidPtr(), &this->rosQueue);
		this->drivetrain_left_rosSub = this->rosNode->subscribe(so);
	}

	// Spin up the queue helper thread.
	this->rosQueueThread =
			std::thread(std::bind(&RobotPlugin::QueueThread, this));


}
/// \brief Handle an incoming message from ROS
/// \param[in] _msg A float value that is used to set the velocity
/// of the Velodyne.
public: void drivetrain_left_cmd(const std_msgs::Float32ConstPtr &_msg)
{
	//this->SetVelocity(_msg->data);
	for(std::size_t i = 0; i < joints.size(); ++i)
	{
		//this->model->GetJointController()->SetVelocityTarget(
		//		this->model->GetJoints()[joints.at(i)]->GetScopedName(), _msg->data);
	}
}

/// \brief ROS helper function that processes messages
private: void QueueThread()
{
	static const double timeout = 0.01;
	while (this->rosNode->ok())
	{
		this->rosQueue.callAvailable(ros::WallDuration(timeout));
	}
}
std::unique_ptr<gazebo::RobotModel> robot;
/// \brief A node used for transport
private: transport::NodePtr node;
private: std::vector<uint16_t> joints;

/// \brief A subscriber to a named topic.
private: transport::SubscriberPtr drivetrain_left_sub;
private: transport::SubscriberPtr drivetrain_right_sub;

/// \brief Pointer to the model.
private: physics::ModelPtr model;

/// \brief Pointer to the joint.
private: physics::JointPtr joint;

/// \brief A PID controller for the joint.
private: common::PID pid;

/// \brief A node use for ROS transport
private: std::unique_ptr<ros::NodeHandle> rosNode;

/// \brief A ROS subscriber
private: ros::Subscriber drivetrain_left_rosSub;
private: ros::Subscriber drivetrain_right_rosSub;

/// \brief A ROS callbackqueue that helps process messages
private: ros::CallbackQueue rosQueue;

/// \brief A thread the keeps running the rosQueue
private: std::thread rosQueueThread;
};

// Tell Gazebo about this plugin, so that Gazebo can call Load on this plugin.
GZ_REGISTER_MODEL_PLUGIN(RobotPlugin)
}
#endif
